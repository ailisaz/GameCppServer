### **C++ 游戏服务器开发日志**

**项目名称：** game-server-cpp
**日期：** 2025年6月
**目标：** 将一个基于Java的原型游戏服务器，重构为一个高性能、可扩展的C++版本，并解决开发过程中遇到的各种挑战。

---

#### **第一阶段：环境搭建与项目初始化 (2025/6/6)**

**1.1 技术选型**

为了实现高性能和高并发，我们决定放弃Java原有的“每个客户端一个线程”模型，转而采用现代C++中成熟的异步事件驱动模型。

*   **核心网络库：** **Asio (Standalone)**
    *   **理由：** 这是一个轻量级、跨平台、性能卓越的C++网络库。其基于Proactor设计模式的异步模型，能用极少的线程处理海量并发连接，是构建高性能服务器的首选。
*   **JSON处理：** **nlohmann/json**
    *   **理由：** 这是一个仅头文件的库，集成极其方便。它提供了类似Python的直观API来操作JSON，性能也非常出色。
*   **日志系统：** **spdlog**
    *   **理由：** 快速、灵活且易于配置的日志库，支持异步日志记录，对性能影响极小。
*   **构建系统：** **CMake**
    *   **理由：** C++领域的事实标准，能够跨平台管理项目构建，并与各种IDE（如Visual Studio, CLion, VS Code）无缝集成。
*   **依赖管理：** **vcpkg**
    *   **理由：** 微软官方的C++包管理器，能自动处理库的下载、编译和集成，极大地简化了Windows平台下的依赖管理。

**1.2 环境配置 (Windows 11)**

1.  **安装核心工具：** 通过 **Visual Studio 2022 Installer** 安装了“使用C++的桌面开发”工作负载，确保了MSVC编译器、Windows SDK和CMake的就位。
2.  **安装vcpkg：** 在 `E:\game-server-cpp\dev` 目录下克隆了`vcpkg`仓库，并运行了`bootstrap-vcpkg.bat`。
3.  **集成vcpkg：** 使用管理员权限运行 `vcpkg integrate install`，使Visual Studio能够自动找到由vcpkg安装的库。
4.  **安装依赖：** 通过 `vcpkg install asio nlohmann-json spdlog` 命令，一键完成了所有第三方库的安装。

**1.3 项目创建**

在Visual Studio 2022中，通过“打开本地文件夹”功能直接打开了包含`CMakeLists.txt`的项目根目录。VS自动识别了CMake项目，并得益于vcpkg的集成，成功配置了所有依赖项。

---

#### **第二阶段：架构设计与核心数据结构 (2025/6/6)**

**2.1 架构设计**

为保证代码的可维护性和扩展性，我们采用了分层和面向对象的设计。

*   **`GameServer` (单例模式):** 作为服务器的核心，全局唯一。它负责：
    *   监听和接受新的客户端连接。
    *   管理所有游戏状态（玩家、食物等）。
    *   驱动游戏主循环（计时器、状态广播）。
    *   处理服务器级的业务逻辑（开始/结束游戏）。
*   **`ClientSession` (会话管理):** 每个客户端连接都由一个`ClientSession`对象表示。它负责：
    *   与单个客户端进行异步的读写操作。
    *   解析来自客户端的JSON消息，并将业务逻辑请求分发给`GameServer`。
    *   管理自身生命周期（通过`std::enable_shared_from_this`）。
*   **异步模型:** 整个服务器基于`asio::io_context`的事件循环构建。我们创建了一个线程池（数量与CPU核心数相当）来运行`io_context`，充分利用多核性能。所有网络I/O和定时器都是异步的，避免了任何阻塞操作。

**2.2 核心数据结构 (`DataTypes.h`)**

为了与客户端保持一致，并方便进行JSON序列化，我们定义了清晰的数据结构。

*   **`PlayerData` struct:**
    *   存储玩家的`id`, `name`, `x`, `y`坐标, `score`, 和 `colorHex`。
    *   利用 `NLOHMANN_DEFINE_TYPE_INTRUSIVE` 宏，实现了与`nlohmann/json`的自动相互转换，代码简洁高效。
*   **`FoodData` struct:**
    *   存储食物的`id`, `x`, `y`坐标，同样利用宏实现了自动JSON转换。

---

#### **第三阶段：功能实现与问题排查 (2025/6/9)**

**3.1 功能实现**

*   实现了客户端连接、断开的全流程管理。
*   实现了玩家位置更新、吃食物等核心游戏逻辑。
*   实现了基于`asio::steady_timer`的游戏主循环，以固定频率（20Hz）向所有客户端广播游戏状态，并实现了每秒一次的游戏倒计时。
*   实现了完整的游戏开始和结束逻辑，包括分数重置、胜负判断和结果广播。

**3.2 遇到的关键问题及解决方案**

**问题一：客户端无法连接服务器**

*   **现象：** 服务端在Visual Studio中成功运行并显示监听日志，但Android客户端连接时超时。
*   **排查过程：**
    1.  **协议验证：** 首先代码审查了客户端（Java）和服务端（C++）的通信协议，确认了消息格式（JSON）、消息分帧（基于换行符`\n`）完全匹配。排除了代码逻辑问题。
    2.  **网络监听确认：** 在服务器电脑上使用 `netstat -ano | findstr "12345"` 命令，确认了`GameServer.exe`进程确已在 `0.0.0.0:12345` 上处于 `LISTENING` 状态。
    3.  **防火墙排查：** 这是最可疑的环节。通过**暂时关闭Windows Defender防火墙**进行测试，发现客户端可以立刻连接成功。
*   **解决方案：** 在客户端重新输入了正确的ip值

**问题二：运行时崩溃，提示`abort() has been called` (死锁问题)**

![屏幕截图 2025-06-09 101752](C:\Users\13040\Pictures\Screenshots\屏幕截图 2025-06-09 101752.png)

![屏幕截图 2025-06-09 101846](C:\Users\13040\Pictures\Screenshots\屏幕截图 2025-06-09 101846.png)

*   **现象：** 当第一个客户端成功连接后，服务器程序立即崩溃，Visual Studio调试器中断在C++标准库`<mutex>`的内部，错误提示为 `_RESOURCE_DEADLOCK_WOULD_OCCUR`。
*   **排查过程：**
    1.  **错误分析：** 该错误明确指出，代码尝试在一个**已经被当前线程锁住的、非递归的互斥锁 (`std::mutex`)** 上再次加锁。
    2.  **代码审查：** 通过分析调用堆栈和审查代码，发现了一个致命的调用链：`HandleClientConnect()`函数首先获取了全局锁`m_mutex`，随后在其锁定的作用域内，又调用了`BroadcastMessage()`函数，而`BroadcastMessage()`函数为了线程安全，也尝试去获取同一个`m_mutex`锁，从而导致了死锁。
*   **解决方案：**
    1.  **初步方案（被否决）：** 考虑重构代码，避免嵌套加锁。但这需要引入`_NoLock`版本的函数，改动较大，且容易出错。
    2.  **最终方案（采纳）：** 采用更简单、直接且安全的方式——**使用递归锁 (`std::recursive_mutex`)**。
        *   将`GameServer`中的成员变量 `std::mutex m_mutex;` 修改为 `std::recursive_mutex m_mutex;`。
        *   将项目中所有 `std::lock_guard<std::mutex>` 替换为 `std::lock_guard<std::recursive_mutex>`。
        *   **关键知识点：** `std::recursive_mutex` 与 `std::mutex` 都定义在同一个头文件 `<mutex>` 中，无需额外`#include`。
    *   **结果：** 替换为递归锁后，允许了同一线程对锁的多次嵌套获取，死锁问题被完美解决，服务器运行稳定。

